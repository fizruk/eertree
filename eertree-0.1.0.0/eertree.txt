-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/fizruk/eertree#readme</a>
@package eertree
@version 0.1.0.0

module EERTREE.Node.Internal.Weakly

-- | <a>Weakly</a> stores a weak link to the result of some function
--   application. Weak link means that the result can be garbage collected
--   after its been used even if weak links still exist.
--   
--   However, <tt><a>Weakly</a> a</tt> also contains a recipe of how to
--   constuct that value if it is needed again in the future.
--   
--   This makes <a>Weakly</a> useful when working with large lazy
--   graph-like data structures to reduce memory usage when a working part
--   of that structure changes.
data Weakly a
Weakly :: (b -> a) -> b -> IORef (Weak a) -> Weakly a

-- | How to (re)construct a value.
[wrRecipe] :: Weakly a -> b -> a

-- | Source.
[wrIngredient] :: Weakly a -> b

-- | A weak link to result.
[wrResult] :: Weakly a -> IORef (Weak a)

-- | Apply function to an argument producing a result that is weakly
--   referenced (and hence can be garbage collected).
applyWeakly :: (a -> b) -> a -> Weakly b

-- | Extract weakly referenced result, reevaluating if necessary.
fromWeakly :: Weakly b -> b
instance Control.DeepSeq.NFData (EERTREE.Node.Internal.Weakly.Weakly a)
instance GHC.Show.Show a => GHC.Show.Show (EERTREE.Node.Internal.Weakly.Weakly a)

module EERTREE.Symbol

-- | A symbol in an alphabet of size <tt>n</tt>.
newtype Symbol (n :: Nat)
Symbol :: Int -> Symbol (n :: Nat)
[fromSymbol] :: Symbol (n :: Nat) -> Int

-- | Symbols of an alphabet of size <tt>n</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; alphabet @2
--   [0,1]
--   
--   &gt;&gt;&gt; alphabet @10
--   [0,1,2,3,4,5,6,7,8,9]
--   </pre>
alphabet :: forall n. KnownNat n => [Symbol n]
instance Control.DeepSeq.NFData (EERTREE.Symbol.Symbol n)
instance GHC.Enum.Enum (EERTREE.Symbol.Symbol n)
instance GHC.Show.Show (EERTREE.Symbol.Symbol n)
instance GHC.Classes.Ord (EERTREE.Symbol.Symbol n)
instance GHC.Classes.Eq (EERTREE.Symbol.Symbol n)
instance GHC.TypeNats.KnownNat n => GHC.Enum.Bounded (EERTREE.Symbol.Symbol n)
instance GHC.Num.Num (EERTREE.Symbol.Symbol n)

module EERTREE.Node

-- | A node corresponsing to a palindrome in an alphabet of size
--   <tt>n</tt>.
data Node (n :: Nat)
Node :: !Integer -> !Int -> Seq (Symbol n) -> Maybe (Symbol n, Node n) -> Vector (Node n) -> Vector (Weakly (Node n)) -> IntMap (Node n) -> Node (n :: Nat)
[index] :: Node (n :: Nat) -> !Integer
[len] :: Node (n :: Nat) -> !Int
[value] :: Node (n :: Nat) -> Seq (Symbol n)
[parent] :: Node (n :: Nat) -> Maybe (Symbol n, Node n)
[ancestors] :: Node (n :: Nat) -> Vector (Node n)
[edges] :: Node (n :: Nat) -> Vector (Weakly (Node n))
[links] :: Node (n :: Nat) -> IntMap (Node n)

-- | First (last) symbol of a palindrome.
--   
--   <pre>
--   &gt;&gt;&gt; symbol (fromPalindrome @2 [1,0,1])
--   Just 1
--   
--   &gt;&gt;&gt; symbol (fromPalindrome @2 [])
--   Nothing
--   </pre>
symbol :: Node n -> Maybe (Symbol n)

-- | Follow an edge in palindromic tree. This corresponds to adding a
--   symbol to both ends of some palindrome.
--   
--   <pre>
--   &gt;&gt;&gt; edge 1 (fromPalindrome @2 [0,1,0])
--   fromPalindrome [1,0,1,0,1]
--   
--   &gt;&gt;&gt; edge 0 (fromPalindrome @2 [])
--   fromPalindrome [0,0]
--   </pre>
edge :: Symbol n -> Node n -> Node n

-- | Follow a direct link to find the largest palindrome suffix preceded by
--   a given symbol in another palindrome.
--   
--   <pre>
--   &gt;&gt;&gt; directLink 1 (fromPalindrome @2 [0,1,0,1,0])
--   fromPalindrome [0,1,0]
--   
--   &gt;&gt;&gt; directLink 0 (fromPalindrome @2 [0,1,0,1,0])
--   fromPalindrome []
--   
--   &gt;&gt;&gt; directLink 1 (fromPalindrome @2 [0,0,0,0,0])
--   oddNode
--   </pre>
directLink :: KnownNat n => Symbol n -> Node n -> Node n

-- | The largest palindrome suffix
--   
--   <pre>
--   &gt;&gt;&gt; link (fromPalindrome @2 [1,0,0,0,1])
--   fromPalindrome [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; link (fromPalindrome @2 [0,0,0])
--   fromPalindrome [0,0]
--   </pre>
link :: KnownNat n => Node n -> Node n

-- | Construct a <tt><a>Node</a> n</tt> from a palindrome.
--   
--   NOTE: this will result in an error if input is not a palindrome.
--   
--   <pre>
--   &gt;&gt;&gt; fromPalindrome @2 [0,1,1]
--   *** Exception: not a palindrome
--   ...
--   </pre>
fromPalindrome :: KnownNat n => [Symbol n] -> Node n

-- | Like <a>symbolAt'</a>, but tries to minimize jumps.
--   
--   <pre>
--   &gt;&gt;&gt; symbolAt 3 (fromPalindrome @2 [0,1,0,1,0,1,0])
--   Just 1
--   
--   &gt;&gt;&gt; pal = fromPalindrome @2 [0,1,0,1,0,1,0]
--   
--   &gt;&gt;&gt; symbolAt 1 pal == symbolAt 5 pal
--   True
--   
--   &gt;&gt;&gt; pal = fromPalindrome @2 [0,1,0,1,0,1,0]
--   
--   &gt;&gt;&gt; symbolAt 3 pal == symbolAt' 3 pal
--   True
--   </pre>
symbolAt :: Int -> Node n -> Maybe (Symbol n)

-- | Find a symbol at a given position in a palindrome. Note that it does
--   not matter from what end you start indexing.
--   
--   <pre>
--   &gt;&gt;&gt; symbolAt' 0 (fromPalindrome @2 [0,1,0])
--   Just 0
--   
--   &gt;&gt;&gt; symbolAt' 1 ((fromPalindrome @2 [0,1,0]))
--   Just 1
--   
--   &gt;&gt;&gt; symbolAt' 2 ((fromPalindrome @2 [0,1,0]))
--   Nothing
--   
--   &gt;&gt;&gt; symbolAt' 3 (fromPalindrome @2 [0,1,0])
--   Nothing
--   
--   &gt;&gt;&gt; symbolAt' (-1) (fromPalindrome @2 [0,1,0])
--   Nothing
--   </pre>
symbolAt' :: Int -> Node n -> Maybe (Symbol n)

-- | Path to the node from one of the roots. This corresponds to the left
--   half of the palindrome a node represents.
--   
--   <pre>
--   &gt;&gt;&gt; pathTo (fromPalindrome @2 [1,1,0,1,1])
--   [1,1,0]
--   </pre>
pathTo :: Node n -> [Symbol n]

-- | Build a <a>Vector</a> of a node's parent ancestors that are $2^i$
--   edges away from the node.
--   
--   <pre>
--   &gt;&gt;&gt; (F.toList . value) &lt;$&gt; getAncestors (fromPalindrome @2 [1,0,1,0,1,0,1])
--   [[1,0,1,0,1,0,1],[0,1,0,1,0],[0]]
--   </pre>
getAncestors :: Node a -> Vector (Node a)

-- | Construct a new node by following an edge. This corresponds to adding
--   a symbol to both ends of a palindrome.
--   
--   <pre>
--   &gt;&gt;&gt; mkEdge 0 (fromPalindrome @2 [])
--   fromPalindrome [0,0]
--   
--   &gt;&gt;&gt; mkEdge 1 (fromPalindrome @2 [0])
--   fromPalindrome [1,0,1]
--   </pre>
mkEdge :: forall n. KnownNat n => Symbol n -> Node n -> Node n

-- | Find what would be the largest suffix of a new palindrome after added
--   a given symbol to the end of another palindrome.
--   
--   <pre>
--   &gt;&gt;&gt; newSuffixOf 1 (fromPalindrome @2 [1,0,1,0,1])
--   fromPalindrome [1,1]
--   
--   &gt;&gt;&gt; newSuffixOf 0 (fromPalindrome @2 [1,0,1,0,1])
--   fromPalindrome [0,1,0,1,0]
--   
--   &gt;&gt;&gt; newSuffixOf 1 (fromPalindrome @2 [0,0,0,0,0])
--   fromPalindrome [1]
--   </pre>
newSuffixOf :: KnownNat n => Symbol n -> Node n -> Node n

-- | Construct direct links for a child node, given its parent and a symbol
--   to add to both ends.
--   
--   <pre>
--   &gt;&gt;&gt; mkDirectLinks 0 (fromPalindrome @2 [0,1,0,1,0])
--   fromList [(0,fromPalindrome [0]),(1,fromPalindrome [0,0])]
--   
--   &gt;&gt;&gt; mkDirectLinks 1 (fromPalindrome @2 [0,1,0,1,0])
--   fromList [(0,fromPalindrome [1,0,1,0,1]),(1,fromPalindrome [])]
--   </pre>
mkDirectLinks :: KnownNat n => Symbol n -> Node n -> IntMap (Node n)

-- | An even node corresponding to an empty palindrome.
--   
--   <pre>
--   &gt;&gt;&gt; evenNode @2
--   fromPalindrome []
--   
--   &gt;&gt;&gt; edge 1 (evenNode @2)
--   fromPalindrome [1,1]
--   </pre>
evenNode :: forall n. KnownNat n => Node n

-- | An odd node, corresponding to a parent of singleton palindromes.
--   
--   <pre>
--   &gt;&gt;&gt; edge 1 (oddNode @2)
--   fromPalindrome [1]
--   </pre>
--   
--   Note that there is no palindrome that corresponds to this node:
--   
--   <pre>
--   &gt;&gt;&gt; oddNode @2
--   oddNode
--   </pre>
oddNode :: forall n. KnownNat n => Node n
instance GHC.Generics.Generic (EERTREE.Node.Node n)
instance Control.DeepSeq.NFData (EERTREE.Node.Node n)
instance GHC.Classes.Eq (EERTREE.Node.Node n)
instance GHC.Classes.Ord (EERTREE.Node.Node n)
instance GHC.Show.Show (EERTREE.Node.Node n)

module EERTREE.Simple

-- | A palindromic tree for some string with auxillary information.
data EERTREE n
EERTREE :: !Int -> Node n -> Node n -> Seq (Symbol n) -> Seq (Symbol n) -> [Node n] -> EERTREE n

-- | Length of the analysed string.
[strLen] :: EERTREE n -> !Int

-- | Maximum palindromic prefix.
[maxPrefix] :: EERTREE n -> Node n

-- | Maximum palindromic suffix
[maxSuffix] :: EERTREE n -> Node n

-- | Prefix, preceding maximum palindromic suffix
[strReversedPrefix] :: EERTREE n -> Seq (Symbol n)

-- | Suffix, following maximum palindromic prefix.
[strSuffix] :: EERTREE n -> Seq (Symbol n)

-- | Accumulated list of encountered palindromes.
[palindromes] :: EERTREE n -> [Node n]

-- | An empty eertree.
empty :: forall n. KnownNat n => EERTREE n

-- | An eertree for a singleton string.
--   
--   <pre>
--   &gt;&gt;&gt; fromEERTREE (singleton @2 0)
--   [0]
--   </pre>
singleton :: KnownNat n => Symbol n -> EERTREE n

-- | Analyse a string by building an eertree.
--   
--   <pre>
--   &gt;&gt;&gt; fromEERTREE (eertree @2 [0,1,0,0,1])
--   [0,1,0,0,1]
--   </pre>
eertree :: KnownNat n => [Symbol n] -> EERTREE n

-- | Build an eertree from string
--   
--   <pre>
--   &gt;&gt;&gt; eertreeFromString @2 "01001" == eertree @2 [0,1,0,0,1]
--   True
--   </pre>
eertreeFromString :: KnownNat n => String -> EERTREE n

-- | EERTREE of a reversed string
--   
--   <pre>
--   &gt; reverseEERTREE @2 "01001" == [1,0,0,1,0]
--   </pre>
--   
--   True
reverseEERTREE :: KnownNat n => EERTREE n -> EERTREE n

-- | Get the string back from an eertree.
--   
--   <pre>
--   &gt;&gt;&gt; fromEERTREE @2 "01001"
--   [0,1,0,0,1]
--   </pre>
fromEERTREE :: EERTREE n -> [Symbol n]
eertreeToSeq :: EERTREE n -> Seq (Symbol n)

-- | Get the reversed string from an eertree
--   
--   <pre>
--   &gt;&gt;&gt; reverseFromEERTREE @2 "01001"
--   [1,0,0,1,0]
--   </pre>
reverseFromEERTREE :: EERTREE n -> [Symbol n]
eertreeToSeqReversed :: EERTREE n -> Seq (Symbol n)

-- | Add a symbol to the beginning of a string corresponding to an eertree.
--   
--   <pre>
--   &gt;&gt;&gt; fromEERTREE (prepend 0 (eertreeFromString @2 "01001"))
--   [0,0,1,0,0,1]
--   </pre>
prepend :: KnownNat n => Symbol n -> EERTREE n -> EERTREE n

-- | Add a symbol to the end of a string corresponding to an eertree
--   
--   <pre>
--   &gt;&gt;&gt; fromEERTREE (append 0 (eertreeFromString @2 "01001"))
--   [0,1,0,0,1,0]
--   </pre>
append :: KnownNat n => Symbol n -> EERTREE n -> EERTREE n

-- | Merge two eertrees in O(1) on average
--   
--   <pre>
--   &gt;&gt;&gt; fromEERTREE (merge @2 "0110100" "11001001")
--   [0,1,1,0,1,0,0,1,1,0,0,1,0,0,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromEERTREE (merge @2 "10010011" "0010110")
--   [1,0,0,1,0,0,1,1,0,0,1,0,1,1,0]
--   </pre>
merge :: KnownNat n => EERTREE n -> EERTREE n -> EERTREE n

-- | Merge two eertrees in min(|S1|, |S2|)
--   
--   <pre>
--   &gt;&gt;&gt; fromEERTREE (mergeLinear @2 "0110100" "11001001")
--   [0,1,1,0,1,0,0,1,1,0,0,1,0,0,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromEERTREE (mergeLinear @2 "10010011" "0010110")
--   [1,0,0,1,0,0,1,1,0,0,1,0,1,1,0]
--   </pre>
mergeLinear :: KnownNat n => EERTREE n -> EERTREE n -> EERTREE n

-- | Unique subpalindromes of a string.
--   
--   <pre>
--   &gt;&gt;&gt; subpalindromes @2 [0,1,0,0,1]
--   [[0,1,0],[1,0,0,1],[0,0],[0],[1]]
--   </pre>
subpalindromes :: KnownNat n => [Symbol n] -> [[Symbol n]]

-- | Compute first &lt;math&gt; elements of <a>A216264 sequence</a> (binary
--   rich strings count for &lt;math&gt;).
--   
--   For memory efficiency the whole sequence segment is computed at once
--   and not lazily as one might expect.
--   
--   This should run in &lt;math&gt; memory with garbage collector working
--   normally.
--   
--   <pre>
--   &gt;&gt;&gt; a216264 15
--   [1,2,4,8,16,32,64,128,252,488,932,1756,3246,5916,10618]
--   </pre>
a216264 :: Int -> [Int]

-- | Palindromic refrain: for a given string S find a palindrome P
--   maximizing the value |P| * occ(S, P), where occ(S, P) is the number of
--   occurences of P in S
--   
--   <pre>
--   &gt;&gt;&gt; palindromicRefrain (eertreeFromString @3 "0102010")
--   (fromPalindrome [0,1,0,2,0,1,0],7)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; palindromicRefrain (eertreeFromString @1 "000")
--   (fromPalindrome [0,0],4)
--   </pre>
palindromicRefrain :: KnownNat n => EERTREE n -> (Node n, Int)

-- | Compute the number of occurences for each subpalindrome
--   
--   <pre>
--   &gt;&gt;&gt; frequency (eertreeFromString @2 "10101")
--   [(fromPalindrome [1,0,1,0,1],1),(fromPalindrome [0,1,0],1),(fromPalindrome [1,0,1],2),(fromPalindrome [1],3),(fromPalindrome [0],2)]
--   </pre>
frequency :: KnownNat n => EERTREE n -> [(Node n, Int)]

-- | Compute the number of occurences for each subpalindrome. Return
--   <tt>Map</tt> of frequences with Node index as a key.
--   
--   <pre>
--   &gt;&gt;&gt; frequency' (eertreeFromString @2 "1000")
--   fromList [(-4,(fromPalindrome [0,0,0],1)),(-3,(fromPalindrome [1],1)),(-2,(fromPalindrome [0],3)),(2,(fromPalindrome [0,0],2))]
--   </pre>
frequency' :: KnownNat n => EERTREE n -> Map Integer (Node n, Int)

-- | Efficiently count nodes at every level of a tree using DFS.
--   
--   Memory efficiency comes from the fact that in depth-first traversal we
--   don't have to store all nodes at a level and only need to store a path
--   from root to the current node.
dfsCountLevels :: Int -> a -> (a -> [a]) -> [Int]

-- | Efficiently compute all rich eertrees that can be produced from a
--   given one by prepending a symbol to it.
--   
--   Efficiency comes from the fact that we only need to check that a new
--   maximum prefix is a new palindrome.
richSubEERTREEs :: forall n. KnownNat n => EERTREE n -> [EERTREE n]
instance GHC.Generics.Generic (EERTREE.Simple.EERTREE n)
instance GHC.Show.Show (EERTREE.Simple.EERTREE n)
instance GHC.Classes.Eq (EERTREE.Simple.EERTREE n)
instance Control.DeepSeq.NFData (EERTREE.Simple.EERTREE n)
instance GHC.TypeNats.KnownNat n => Data.String.IsString (EERTREE.Simple.EERTREE n)

module EERTREE.Random

-- | Generate list of random symbols of length <tt>len</tt>
--   
--   <pre>
--   genRandomSymbols @4 10
--   </pre>
--   
--   <ul>
--   <li><i>3,2,3,1,2,3,0,0,2,0</i></li>
--   </ul>
randomSymbolsIO :: KnownNat n => Int -> IO [Symbol n]

-- | Generator for list of random symbols of length <tt>len</tt>
randomSymbols :: KnownNat n => Int -> Gen [Symbol n]

-- | Generator for eertree from random list of symbols of length
--   <tt>len</tt>
randomEERTREE :: KnownNat n => Int -> Gen (EERTREE n)

-- | Generate pair of random eertrees of lengths <tt>len1</tt> and
--   <tt>len2</tt>
randomEERTREEpairIO :: KnownNat n => Int -> Int -> IO (EERTREE n, EERTREE n)

-- | Count number of new palindromes after merging two random eertrees
randomMerge :: forall n. KnownNat n => Proxy n -> Int -> Gen Int

-- | <pre>
--   &gt; generate (genAverageMerge (Proxy <tt>2) 100 500)
--   7.416
--   &gt; generate (genAverageMerge (Proxy </tt>4) 100 500)
--   3.09
--   &gt; generate (genAverageMerge (Proxy @33) 100 500)
--   2.024
--   </pre>
genAverageMerge :: forall n. KnownNat n => Proxy n -> Int -> Int -> Gen Double
